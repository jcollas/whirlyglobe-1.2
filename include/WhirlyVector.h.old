//
//  WhirlyVector.h
//  WhirlyGlobeLib
//
//  Created by Stephen Gifford on 1/3/11.
//  Copyright 2011 mousebird consulting. All rights reserved.
//

#import <Foundation/Foundation.h>
#import <boost/numeric/ublas/storage.hpp>
#import <boost/numeric/ublas/vector.hpp>
#import <boost/numeric/ublas/matrix.hpp>
#import <ostream>

namespace WhirlyGlobe {
	
// Something that acts more like a 3D point
template<typename T>
class Point3D : public boost::numeric::ublas::bounded_vector<T,3>
{
public:
	Point3D() : boost::numeric::ublas::bounded_vector<T,3>(3) { };
	Point3D(T x,T y,T z) : boost::numeric::ublas::bounded_vector<T,3>(3) { (*this)[0] = x; (*this)[1] = y; (*this)[2] = z; }
	Point3D & operator = (const boost::numeric::ublas::bounded_vector<T,3> &that) { *((boost::numeric::ublas::bounded_vector<T,3> *)this) = that; return *this; }
	float &x() { return (*this)[0]; }
	float &y() { return (*this)[1]; }
	float &z() { return (*this)[2]; }	
};

// Specific float version of 3D point.  Use this.
class Point3Df : public Point3D<float>
{
public:
	Point3Df(float x, float y, float z) : Point3D<float>(x,y,z) { }
	Point3Df normalize() { float denom = boost::numeric::ublas::norm_2(*this); return Point3Df(x()/denom,y()/denom,z()/denom); }
	NSString *debugString() { return [[NSString stringWithFormat:@"(%f,%f,%f)",x(),y(),z()] retain]; }
};
// typedef Point3D<float> Point3Df;
	
// Something that acts like a 2D point
template<typename T>
class Point2D : public boost::numeric::ublas::bounded_vector<T,2>
{
public:
	Point2D() : boost::numeric::ublas::bounded_vector<T,2>(2) { };
	Point2D(float x,float y) : boost::numeric::ublas::bounded_vector<T,2>(2) { (*this)[0] = x; (*this)[1] = y; }
	Point2D & operator = (const boost::numeric::ublas::bounded_vector<T,2> &that) { *((boost::numeric::ublas::bounded_vector<T,2> *)this) = that; return *this; }
	float &x() { return (*this)[0]; }
	float &y() { return (*this)[1]; }
	void print() { std::cout << "(" << x() << "," << y() << ")" << "\n"; }
	NSString *debugString() { return [[NSString stringWithFormat:@"(%f,%f)",x(),y()] retain]; };
};
	
// Specific float version of 2D point.  Use this.
typedef Point2D<float> Point2Df;

// Specialization of 2D point for u/v convenience functions
class TextureCoord : public Point2Df
{
public:
	TextureCoord(float u,float v) : Point2Df(u,v) { }
	float &u() { return (*this)[0]; }
	float &v() { return (*this)[1]; }
};
	
// Specialization of 2D point for geodetic value
// Latitude is stored in Y
// These are radians
class GeoCoord : public Point2Df
{
public:
	GeoCoord(float lon,float lat) : Point2Df(lon,lat) { }
	float &lat() { return (*this)[1]; }
	float &lon() { return (*this)[0]; }

	NSString *debugString() { return [[NSString stringWithFormat:@"(lon,lat): (%f,%f) degrees",(float)(x()*180.0/M_PI),(float)(y()*180.0/M_PI)] retain]; };
};

// 3x3 matrix based on boost
template<typename T>
class Matrix3D : public boost::numeric::ublas::bounded_matrix<T,3,3>
{
public:
	Matrix3D() : boost::numeric::ublas::bounded_matrix<T,3,3>(3,3) { };
	Matrix3D & operator = (const boost::numeric::ublas::bounded_matrix<T,3,3> &that) { *((boost::numeric::ublas::bounded_matrix<T,3,3> *)this) = that; return *this; }
	NSString *debugString()
	{
		NSMutableString *str = [[NSMutableString alloc] init];
		for (unsigned int ix=0;ix<3;ix++)
		{
			[str appendFormat:@"%f %f %f",(*this)(ix,0),(*this)(ix,1),(*this)(ix,2)];
		}
		
		return str;
	}
};

// Specific float version of 3x3 matrix.  Use this.
typedef Matrix3D<float> Matrix3Df;
	
// 4x4 matrix based on boost
template<typename T>
class Matrix4D : public boost::numeric::ublas::bounded_matrix<T,4,4>
{
public:
	Matrix4D() : boost::numeric::ublas::bounded_matrix<T,4,4>(4,4) { };
	Matrix4D & operator = (const boost::numeric::ublas::bounded_matrix<T,4,4> &that) { *((boost::numeric::ublas::bounded_matrix<T,4,4> *)this) = that; return *this; }
	NSString *debugString()
	{
		NSMutableString *str = [[NSMutableString alloc] init];
		for (unsigned int ix=0;ix<3;ix++)
		{
			[str appendFormat:@"%f %f %f %f",(*this)(ix,0),(*this)(ix,1),(*this)(ix,2),(*this)(ix,3)];
		}
		
		return str;
	}
};

// Specific float version of 4x4 matrix.  Use this.
typedef Matrix4D<float> Matrix4Df;
	
}
